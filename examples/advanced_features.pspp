#!/usr/bin/env psp
# -*- coding: utf-8 -*-

/**
 * PSP ê³ ê¸‰ ë¬¸ë²• ì˜ˆì œ
 * Advanced PSP Language Features Demo
 * @author PSP Development Team
 * @version 1.0
 */

print("=== PSP ê³ ê¸‰ ë¬¸ë²• ë°ëª¨ ===\n")

# 1. í´ë˜ìŠ¤ì™€ ê°ì²´ ì§€í–¥ í”„ë¡œê·¸ë˜ë°
print("1. í´ë˜ìŠ¤ì™€ ìƒì† ì˜ˆì œ:")

class SecurityTool {
    constructor(name, version) {
        this.name = name
        this.version = version
        this.scan_count = 0
        this.results = {}
    }
    
    function get_info() {
        return "${this.name} v${this.version}"
    }
    
    function log_activity(message) {
        printf("[%s] %s", this.name, message)
    }
    
    function increment_scan() {
        this.scan_count++
    }
}

class PortScanner extends SecurityTool {
    constructor(name, version, timeout = 5.0) {
        super(name, version)  # ë¶€ëª¨ ìƒì„±ì í˜¸ì¶œ
        this.timeout = timeout
        this.scan_type = "TCP"
    }
    
    function scan_host(host, ports) {
        this.log_activity("í¬íŠ¸ ìŠ¤ìº” ì‹œì‘: ${host}")
        
        for port in ports {
            this.increment_scan()
            
            if scan_port(host, port) {
                this.results[port] = "open"
                printf("  í¬íŠ¸ %d: ì—´ë¦¼", port)
            } else {
                this.results[port] = "closed"
            }
        }
        
        this.log_activity("ìŠ¤ìº” ì™„ë£Œ - ì´ ${this.scan_count}ê°œ í¬íŠ¸ í…ŒìŠ¤íŠ¸")
        return this.results
    }
    
    # ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ
    function get_info() {
        base_info = super.get_info()
        return "${base_info} (${this.scan_type} Scanner, timeout: ${this.timeout}s)"
    }
}

# í´ë˜ìŠ¤ ì‚¬ìš©
scanner = new PortScanner("PSP Scanner", "1.0", 3.0)
print(scanner.get_info())

test_ports = [80, 443, 22]
scan_results = scanner.scan_host("127.0.0.1", test_ports)

print("\nìŠ¤ìº” ê²°ê³¼:")
for port, status in scan_results.items() {
    printf("  í¬íŠ¸ %d: %s", port, status)
}

print("\n" + "="*50 + "\n")

# 2. ì˜ˆì™¸ ì²˜ë¦¬ì™€ ì˜¤ë¥˜ ê´€ë¦¬
print("2. ì˜ˆì™¸ ì²˜ë¦¬ ì˜ˆì œ:")

class NetworkError extends Error {
    constructor(message, host, port) {
        super(message)
        this.host = host
        this.port = port
        this.error_type = "NETWORK_ERROR"
    }
}

function safe_scan_port(host, port) {
    try {
        result = scan_port(host, port)
        return {"success": true, "result": result}
    } catch NetworkError as e {
        printf("ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: %s:%d - %s", e.host, e.port, e.message)
        return {"success": false, "error": e.message}
    } catch Error as e {
        printf("ì¼ë°˜ ì˜¤ë¥˜: %s", e.message)
        return {"success": false, "error": e.message}
    } finally {
        # ì •ë¦¬ ì‘ì—…
        log("ìŠ¤ìº” ì‹œë„ ì™„ë£Œ", "DEBUG")
    }
}

# ì•ˆì „í•œ ìŠ¤ìº” ì‹œë„
result = safe_scan_port("127.0.0.1", 80)
if result.success {
    print("ìŠ¤ìº” ì„±ê³µ!")
} else {
    printf("ìŠ¤ìº” ì‹¤íŒ¨: %s", result.error)
}

print("\n" + "="*50 + "\n")

# 3. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ê³¼ ëŒë‹¤
print("3. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì˜ˆì œ:")

# ëŒë‹¤ í•¨ìˆ˜
is_common_port = (port) => port in [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995]
get_service_name = (port) => {
    services = {
        21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP",
        53: "DNS", 80: "HTTP", 110: "POP3", 135: "RPC",
        139: "NetBIOS", 143: "IMAP", 443: "HTTPS",
        993: "IMAPS", 995: "POP3S"
    }
    return services.get(port, "Unknown")
}

# ê³ ì°¨ í•¨ìˆ˜ ì‚¬ìš©
all_ports = range(1, 1001)
common_ports = all_ports.filter(is_common_port)
service_map = common_ports.map((port) => {
    return {"port": port, "service": get_service_name(port)}
})

print("ì¼ë°˜ì ì¸ ì„œë¹„ìŠ¤ í¬íŠ¸ë“¤:")
for service_info in service_map {
    printf("  í¬íŠ¸ %d: %s", service_info.port, service_info.service)
}

# reduce í•¨ìˆ˜ ì˜ˆì œ (ê°„ë‹¨í•œ í†µê³„)
port_count = common_ports.reduce((total, port) => total + 1, 0)
printf("\nì´ ì¼ë°˜ í¬íŠ¸ ìˆ˜: %dê°œ", port_count)

print("\n" + "="*50 + "\n")

# 4. ë¬¸ìì—´ ì²˜ë¦¬ì™€ ì •ê·œì‹
print("4. ë¬¸ìì—´ ì²˜ë¦¬ì™€ íŒ¨í„´ ë§¤ì¹­:")

# ë¬¸ìì—´ ë³´ê°„ê³¼ ì²˜ë¦¬
target_ip = "192.168.1.100"
scan_type = "comprehensive"
timestamp = "2024-10-25 14:30:00"

report_header = """
ìŠ¤ìº” ë³´ê³ ì„œ
==========
ëŒ€ìƒ: ${target_ip}
ìœ í˜•: ${scan_type}
ì‹œê°„: ${timestamp}
"""

print(report_header)

# IP ì£¼ì†Œ ê²€ì¦ (ì •ê·œì‹ íŒ¨í„´ ë§¤ì¹­)
ip_addresses = ["192.168.1.1", "10.0.0.1", "invalid_ip", "127.0.0.1", "256.1.1.1"]

valid_ips = []
for ip in ip_addresses {
    # IP ì£¼ì†Œ íŒ¨í„´ ë§¤ì¹­
    if ip =~ r"^(\d{1,3}\.){3}\d{1,3}$" {
        # ê° ì˜¥í…Ÿì´ 0-255 ë²”ìœ„ì¸ì§€ í™•ì¸
        octets = ip.split(".")
        is_valid = true
        
        for octet in octets {
            if int(octet) > 255 {
                is_valid = false
                break
            }
        }
        
        if is_valid {
            valid_ips.append(ip)
            printf("âœ“ ìœ íš¨í•œ IP: %s", ip)
        } else {
            printf("âœ— ë²”ìœ„ ì´ˆê³¼: %s", ip)
        }
    } else {
        printf("âœ— ì˜ëª»ëœ í˜•ì‹: %s", ip)
    }
}

printf("\nì´ %dê°œì˜ ìœ íš¨í•œ IP ì£¼ì†Œë¥¼ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.", len(valid_ips))

print("\n" + "="*50 + "\n")

# 5. ë¹„ë™ê¸° ì²˜ë¦¬ (ê°œë…ì  ì˜ˆì œ)
print("5. ë³‘ë ¬ ì²˜ë¦¬ ê°œë… ì˜ˆì œ:")

# ì—¬ëŸ¬ í˜¸ìŠ¤íŠ¸ë¥¼ ë™ì‹œì— ìŠ¤ìº”í•˜ëŠ” ê°œë…
function parallel_scan_demo(hosts, port) {
    print("ë³‘ë ¬ ìŠ¤ìº” ì‹œë®¬ë ˆì´ì…˜...")
    
    results = {}
    total_hosts = len(hosts)
    
    # ì‹¤ì œë¡œëŠ” ë¹„ë™ê¸° ì²˜ë¦¬ë˜ì§€ë§Œ ì—¬ê¸°ì„œëŠ” ìˆœì°¨ ì²˜ë¦¬ë¡œ ì‹œë®¬ë ˆì´ì…˜
    for i, host in enumerate(hosts) {
        progress = ((i + 1) / total_hosts) * 100
        printf("ì§„í–‰ë¥ : %.1f%% - ìŠ¤ìº” ì¤‘: %s", progress, host)
        
        # ì‹¤ì œ ìŠ¤ìº” ëŒ€ì‹  ì‹œë®¬ë ˆì´ì…˜
        is_alive = (i % 2 == 0)  # ì‹œë®¬ë ˆì´ì…˜: ì§ìˆ˜ ì¸ë±ìŠ¤ë§Œ "í™œì„±"
        results[host] = is_alive
        
        if is_alive {
            printf("  %s: ì‘ë‹µ", host)
        } else {
            printf("  %s: ë¬´ì‘ë‹µ", host)
        }
    }
    
    return results
}

test_hosts = ["192.168.1.1", "192.168.1.2", "192.168.1.3", "192.168.1.4"]
parallel_results = parallel_scan_demo(test_hosts, 80)

active_hosts = parallel_results.filter((host, status) => status)
printf("\ní™œì„± í˜¸ìŠ¤íŠ¸: %dê°œ", len(active_hosts))

print("\n" + "="*50 + "\n")

# 6. ë©”íƒ€í”„ë¡œê·¸ë˜ë°ê³¼ ë¦¬í”Œë ‰ì…˜ (ê°œë…ì )
print("6. ë™ì  ê¸°ëŠ¥ ì˜ˆì œ:")

# ë™ì  í•¨ìˆ˜ í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
function dynamic_function_call(func_name, args) {
    # ì‹¤ì œ PSPì—ì„œëŠ” ë¦¬í”Œë ‰ì…˜ ê¸°ëŠ¥ìœ¼ë¡œ êµ¬í˜„
    if func_name == "md5" {
        return md5(args[0])
    } else if func_name == "sha256" {
        return sha256(args[0])
    } else if func_name == "base64_encode" {
        return base64_encode(args[0])
    } else {
        return "ì§€ì›í•˜ì§€ ì•ŠëŠ” í•¨ìˆ˜: ${func_name}"
    }
}

# ë™ì  í˜¸ì¶œ í…ŒìŠ¤íŠ¸
test_data = "PSP_TEST_DATA"
hash_functions = ["md5", "sha256", "base64_encode"]

print("ë™ì  í•¨ìˆ˜ í˜¸ì¶œ ê²°ê³¼:")
for func_name in hash_functions {
    result = dynamic_function_call(func_name, [test_data])
    printf("  %s('%s') = %s", func_name, test_data, result)
}

print("\n" + "="*50 + "\n")

# 7. ë³µí•© ë°ì´í„° êµ¬ì¡°ì™€ JSON
print("7. ë³µí•© ë°ì´í„° êµ¬ì¡° ì˜ˆì œ:")

# ë³µì¡í•œ ìŠ¤ìº” ê²°ê³¼ êµ¬ì¡°
scan_report = {
    "metadata": {
        "scan_id": "PSP_SCAN_001",
        "timestamp": "2024-10-25T14:30:00Z",
        "scanner": "PSP Advanced Scanner",
        "version": "1.0"
    },
    "targets": [
        {
            "host": "192.168.1.100",
            "hostname": "web-server",
            "os": "Linux",
            "ports": {
                "open": [22, 80, 443],
                "closed": [21, 23, 25],
                "filtered": [135, 139]
            },
            "services": [
                {"port": 22, "service": "SSH", "version": "OpenSSH 7.4"},
                {"port": 80, "service": "HTTP", "version": "Apache 2.4.41"},
                {"port": 443, "service": "HTTPS", "version": "Apache 2.4.41"}
            ],
            "vulnerabilities": [
                {
                    "type": "Outdated SSH",
                    "severity": "medium",
                    "description": "SSH ë²„ì „ì´ ì˜¤ë˜ë˜ì—ˆìŠµë‹ˆë‹¤.",
                    "recommendation": "SSHë¥¼ ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”."
                }
            ]
        }
    ],
    "statistics": {
        "total_hosts": 1,
        "total_ports_scanned": 100,
        "open_ports": 3,
        "services_identified": 3,
        "vulnerabilities_found": 1
    }
}

# ë³´ê³ ì„œ ë¶„ì„
print("ìŠ¤ìº” ë³´ê³ ì„œ ë¶„ì„:")
metadata = scan_report.metadata
printf("ìŠ¤ìº” ID: %s", metadata.scan_id)
printf("ìŠ¤ìº” ë„êµ¬: %s v%s", metadata.scanner, metadata.version)

for target in scan_report.targets {
    printf("\nëŒ€ìƒ: %s (%s)", target.host, target.hostname)
    printf("ìš´ì˜ì²´ì œ: %s", target.os)
    
    open_ports = target.ports.open
    printf("ì—´ë¦° í¬íŠ¸: %s", str(open_ports))
    
    print("ì„œë¹„ìŠ¤:")
    for service in target.services {
        printf("  í¬íŠ¸ %d: %s (%s)", service.port, service.service, service.version)
    }
    
    if len(target.vulnerabilities) > 0 {
        print("ì·¨ì•½ì :")
        for vuln in target.vulnerabilities {
            printf("  [%s] %s", vuln.severity.upper(), vuln.type)
            printf("    ì„¤ëª…: %s", vuln.description)
            printf("    ê¶Œì¥ì‚¬í•­: %s", vuln.recommendation)
        }
    }
}

stats = scan_report.statistics
printf("\ní†µê³„:")
printf("  ì „ì²´ í˜¸ìŠ¤íŠ¸: %d", stats.total_hosts)
printf("  ìŠ¤ìº”í•œ í¬íŠ¸: %d", stats.total_ports_scanned)
printf("  ì—´ë¦° í¬íŠ¸: %d", stats.open_ports)
printf("  ì‹ë³„ëœ ì„œë¹„ìŠ¤: %d", stats.services_identified)
printf("  ë°œê²¬ëœ ì·¨ì•½ì : %d", stats.vulnerabilities_found)

print("\n" + "="*70)
print("PSP ê³ ê¸‰ ë¬¸ë²• ë°ëª¨ ì™„ë£Œ! ğŸ‰")
print("ë” ë§ì€ ì˜ˆì œëŠ” docs/tutorial.mdë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.")
log("ê³ ê¸‰ ë¬¸ë²• ë°ëª¨ ì‹¤í–‰ ì™„ë£Œ", "SUCCESS")
