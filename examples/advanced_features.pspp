#!/usr/bin/env psp
# -*- coding: utf-8 -*-

/**
 * PSP 고급 문법 예제
 * Advanced PSP Language Features Demo
 * @author PSP Development Team
 * @version 1.0
 */

print("=== PSP 고급 문법 데모 ===\n")

# 1. 클래스와 객체 지향 프로그래밍
print("1. 클래스와 상속 예제:")

class SecurityTool {
    constructor(name, version) {
        this.name = name
        this.version = version
        this.scan_count = 0
        this.results = {}
    }
    
    function get_info() {
        return "${this.name} v${this.version}"
    }
    
    function log_activity(message) {
        printf("[%s] %s", this.name, message)
    }
    
    function increment_scan() {
        this.scan_count++
    }
}

class PortScanner extends SecurityTool {
    constructor(name, version, timeout = 5.0) {
        super(name, version)  # 부모 생성자 호출
        this.timeout = timeout
        this.scan_type = "TCP"
    }
    
    function scan_host(host, ports) {
        this.log_activity("포트 스캔 시작: ${host}")
        
        for port in ports {
            this.increment_scan()
            
            if scan_port(host, port) {
                this.results[port] = "open"
                printf("  포트 %d: 열림", port)
            } else {
                this.results[port] = "closed"
            }
        }
        
        this.log_activity("스캔 완료 - 총 ${this.scan_count}개 포트 테스트")
        return this.results
    }
    
    # 메서드 오버라이드
    function get_info() {
        base_info = super.get_info()
        return "${base_info} (${this.scan_type} Scanner, timeout: ${this.timeout}s)"
    }
}

# 클래스 사용
scanner = new PortScanner("PSP Scanner", "1.0", 3.0)
print(scanner.get_info())

test_ports = [80, 443, 22]
scan_results = scanner.scan_host("127.0.0.1", test_ports)

print("\n스캔 결과:")
for port, status in scan_results.items() {
    printf("  포트 %d: %s", port, status)
}

print("\n" + "="*50 + "\n")

# 2. 예외 처리와 오류 관리
print("2. 예외 처리 예제:")

class NetworkError extends Error {
    constructor(message, host, port) {
        super(message)
        this.host = host
        this.port = port
        this.error_type = "NETWORK_ERROR"
    }
}

function safe_scan_port(host, port) {
    try {
        result = scan_port(host, port)
        return {"success": true, "result": result}
    } catch NetworkError as e {
        printf("네트워크 오류: %s:%d - %s", e.host, e.port, e.message)
        return {"success": false, "error": e.message}
    } catch Error as e {
        printf("일반 오류: %s", e.message)
        return {"success": false, "error": e.message}
    } finally {
        # 정리 작업
        log("스캔 시도 완료", "DEBUG")
    }
}

# 안전한 스캔 시도
result = safe_scan_port("127.0.0.1", 80)
if result.success {
    print("스캔 성공!")
} else {
    printf("스캔 실패: %s", result.error)
}

print("\n" + "="*50 + "\n")

# 3. 함수형 프로그래밍과 람다
print("3. 함수형 프로그래밍 예제:")

# 람다 함수
is_common_port = (port) => port in [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995]
get_service_name = (port) => {
    services = {
        21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP",
        53: "DNS", 80: "HTTP", 110: "POP3", 135: "RPC",
        139: "NetBIOS", 143: "IMAP", 443: "HTTPS",
        993: "IMAPS", 995: "POP3S"
    }
    return services.get(port, "Unknown")
}

# 고차 함수 사용
all_ports = range(1, 1001)
common_ports = all_ports.filter(is_common_port)
service_map = common_ports.map((port) => {
    return {"port": port, "service": get_service_name(port)}
})

print("일반적인 서비스 포트들:")
for service_info in service_map {
    printf("  포트 %d: %s", service_info.port, service_info.service)
}

# reduce 함수 예제 (간단한 통계)
port_count = common_ports.reduce((total, port) => total + 1, 0)
printf("\n총 일반 포트 수: %d개", port_count)

print("\n" + "="*50 + "\n")

# 4. 문자열 처리와 정규식
print("4. 문자열 처리와 패턴 매칭:")

# 문자열 보간과 처리
target_ip = "192.168.1.100"
scan_type = "comprehensive"
timestamp = "2024-10-25 14:30:00"

report_header = """
스캔 보고서
==========
대상: ${target_ip}
유형: ${scan_type}
시간: ${timestamp}
"""

print(report_header)

# IP 주소 검증 (정규식 패턴 매칭)
ip_addresses = ["192.168.1.1", "10.0.0.1", "invalid_ip", "127.0.0.1", "256.1.1.1"]

valid_ips = []
for ip in ip_addresses {
    # IP 주소 패턴 매칭
    if ip =~ r"^(\d{1,3}\.){3}\d{1,3}$" {
        # 각 옥텟이 0-255 범위인지 확인
        octets = ip.split(".")
        is_valid = true
        
        for octet in octets {
            if int(octet) > 255 {
                is_valid = false
                break
            }
        }
        
        if is_valid {
            valid_ips.append(ip)
            printf("✓ 유효한 IP: %s", ip)
        } else {
            printf("✗ 범위 초과: %s", ip)
        }
    } else {
        printf("✗ 잘못된 형식: %s", ip)
    }
}

printf("\n총 %d개의 유효한 IP 주소를 발견했습니다.", len(valid_ips))

print("\n" + "="*50 + "\n")

# 5. 비동기 처리 (개념적 예제)
print("5. 병렬 처리 개념 예제:")

# 여러 호스트를 동시에 스캔하는 개념
function parallel_scan_demo(hosts, port) {
    print("병렬 스캔 시뮬레이션...")
    
    results = {}
    total_hosts = len(hosts)
    
    # 실제로는 비동기 처리되지만 여기서는 순차 처리로 시뮬레이션
    for i, host in enumerate(hosts) {
        progress = ((i + 1) / total_hosts) * 100
        printf("진행률: %.1f%% - 스캔 중: %s", progress, host)
        
        # 실제 스캔 대신 시뮬레이션
        is_alive = (i % 2 == 0)  # 시뮬레이션: 짝수 인덱스만 "활성"
        results[host] = is_alive
        
        if is_alive {
            printf("  %s: 응답", host)
        } else {
            printf("  %s: 무응답", host)
        }
    }
    
    return results
}

test_hosts = ["192.168.1.1", "192.168.1.2", "192.168.1.3", "192.168.1.4"]
parallel_results = parallel_scan_demo(test_hosts, 80)

active_hosts = parallel_results.filter((host, status) => status)
printf("\n활성 호스트: %d개", len(active_hosts))

print("\n" + "="*50 + "\n")

# 6. 메타프로그래밍과 리플렉션 (개념적)
print("6. 동적 기능 예제:")

# 동적 함수 호출 시뮬레이션
function dynamic_function_call(func_name, args) {
    # 실제 PSP에서는 리플렉션 기능으로 구현
    if func_name == "md5" {
        return md5(args[0])
    } else if func_name == "sha256" {
        return sha256(args[0])
    } else if func_name == "base64_encode" {
        return base64_encode(args[0])
    } else {
        return "지원하지 않는 함수: ${func_name}"
    }
}

# 동적 호출 테스트
test_data = "PSP_TEST_DATA"
hash_functions = ["md5", "sha256", "base64_encode"]

print("동적 함수 호출 결과:")
for func_name in hash_functions {
    result = dynamic_function_call(func_name, [test_data])
    printf("  %s('%s') = %s", func_name, test_data, result)
}

print("\n" + "="*50 + "\n")

# 7. 복합 데이터 구조와 JSON
print("7. 복합 데이터 구조 예제:")

# 복잡한 스캔 결과 구조
scan_report = {
    "metadata": {
        "scan_id": "PSP_SCAN_001",
        "timestamp": "2024-10-25T14:30:00Z",
        "scanner": "PSP Advanced Scanner",
        "version": "1.0"
    },
    "targets": [
        {
            "host": "192.168.1.100",
            "hostname": "web-server",
            "os": "Linux",
            "ports": {
                "open": [22, 80, 443],
                "closed": [21, 23, 25],
                "filtered": [135, 139]
            },
            "services": [
                {"port": 22, "service": "SSH", "version": "OpenSSH 7.4"},
                {"port": 80, "service": "HTTP", "version": "Apache 2.4.41"},
                {"port": 443, "service": "HTTPS", "version": "Apache 2.4.41"}
            ],
            "vulnerabilities": [
                {
                    "type": "Outdated SSH",
                    "severity": "medium",
                    "description": "SSH 버전이 오래되었습니다.",
                    "recommendation": "SSH를 최신 버전으로 업데이트하세요."
                }
            ]
        }
    ],
    "statistics": {
        "total_hosts": 1,
        "total_ports_scanned": 100,
        "open_ports": 3,
        "services_identified": 3,
        "vulnerabilities_found": 1
    }
}

# 보고서 분석
print("스캔 보고서 분석:")
metadata = scan_report.metadata
printf("스캔 ID: %s", metadata.scan_id)
printf("스캔 도구: %s v%s", metadata.scanner, metadata.version)

for target in scan_report.targets {
    printf("\n대상: %s (%s)", target.host, target.hostname)
    printf("운영체제: %s", target.os)
    
    open_ports = target.ports.open
    printf("열린 포트: %s", str(open_ports))
    
    print("서비스:")
    for service in target.services {
        printf("  포트 %d: %s (%s)", service.port, service.service, service.version)
    }
    
    if len(target.vulnerabilities) > 0 {
        print("취약점:")
        for vuln in target.vulnerabilities {
            printf("  [%s] %s", vuln.severity.upper(), vuln.type)
            printf("    설명: %s", vuln.description)
            printf("    권장사항: %s", vuln.recommendation)
        }
    }
}

stats = scan_report.statistics
printf("\n통계:")
printf("  전체 호스트: %d", stats.total_hosts)
printf("  스캔한 포트: %d", stats.total_ports_scanned)
printf("  열린 포트: %d", stats.open_ports)
printf("  식별된 서비스: %d", stats.services_identified)
printf("  발견된 취약점: %d", stats.vulnerabilities_found)

print("\n" + "="*70)
print("PSP 고급 문법 데모 완료! 🎉")
print("더 많은 예제는 docs/tutorial.md를 참조하세요.")
log("고급 문법 데모 실행 완료", "SUCCESS")
