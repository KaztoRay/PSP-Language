#!/usr/bin/env psp
# -*- coding: utf-8 -*-

/**
 * PSP 보안 및 해킹 도구 종합 예제
 * 화이트햇 해킹과 보안 테스트에 특화된 기능들
 * Features: 네트워크 스캔, 취약점 분석, 암호화, 익스플로잇, 포렌식
 */

print("=== PSP 보안 및 해킹 도구 종합 예제 ===\n")

# ============================================================================
# 1. 네트워크 정찰 및 스캔 (Network Reconnaissance and Scanning)
# ============================================================================

print("1. 네트워크 정찰 및 스캔")
print("-".repeat(30))

# 대상 호스트 정의
string[] target_hosts = ["scanme.nmap.org", "testphp.vulnweb.com", "demo.testfire.net"]
int[] common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306]

# 호스트 발견 스캔
function bool host_discovery(string target) {
    printf("호스트 발견 스캔: %s\n", target)
    
    # ICMP 핑
    bool icmp_result = ping(target, 3)
    printf("  ICMP 핑: %s\n", icmp_result ? "응답" : "무응답")
    
    # TCP 핑 (포트 80)
    bool tcp_result = tcp_connect(target, 80, 3)
    printf("  TCP 핑 (80): %s\n", tcp_result ? "연결됨" : "연결 실패")
    
    return icmp_result || tcp_result
}

# 포트 스캔 (TCP Connect 스캔)
function dict<int, string> tcp_connect_scan(string target, int[] ports) {
    printf("TCP Connect 스캔: %s\n", target)
    dict<int, string> results = {}
    
    foreach (port in ports) {
        bool is_open = tcp_connect(target, port, 1)
        string service = get_service_name(port)
        
        if (is_open) {
            results[port] = service ?: "unknown"
            printf("  포트 %d: 열림 (%s)\n", port, service)
        }
    }
    
    return results
}

# SYN 스캔 (스텔스 스캔)
function dict<int, string> syn_scan(string target, int[] ports) {
    printf("SYN 스캔 (스텔스): %s\n", target)
    dict<int, string> results = {}
    
    foreach (port in ports) {
        string result = tcp_syn_scan(target, port)
        
        if (result == "open") {
            string service = get_service_name(port)
            results[port] = service ?: "unknown"
            printf("  포트 %d: 열림 (%s)\n", port, service)
        } else if (result == "filtered") {
            printf("  포트 %d: 필터링됨\n", port)
        }
    }
    
    return results
}

# UDP 스캔
function void udp_scan(string target, int[] ports) {
    printf("UDP 스캔: %s\n", target)
    
    foreach (port in ports) {
        string result = udp_port_scan(target, port)
        if (result == "open" || result == "open|filtered") {
            printf("  UDP 포트 %d: %s\n", port, result)
        }
    }
}

# 실행
foreach (host in target_hosts) {
    print("\n" + "=".repeat(50))
    
    if (host_discovery(host)) {
        dict<int, string> tcp_results = tcp_connect_scan(host, common_ports)
        printf("발견된 TCP 포트: %d개\n", tcp_results.length)
    } else {
        printf("호스트 %s에 연결할 수 없습니다\n", host)
    }
}

# ============================================================================
# 2. 서비스 및 버전 탐지 (Service and Version Detection)
# ============================================================================

print("\n\n2. 서비스 및 버전 탐지")
print("-".repeat(30))

# 배너 그래빙
function string banner_grab(string host, int port) {
    printf("배너 그래빙: %s:%d\n", host, port)
    
    try {
        string banner = tcp_banner_grab(host, port, 5)
        if (banner.length > 0) {
            printf("  배너: %s\n", banner.trim())
            return banner
        }
    } catch (Exception ex) {
        printf("  배너 그래빙 실패: %s\n", ex.get_message())
    }
    
    return ""
}

# HTTP 서비스 정보 수집
function dict<string, string> http_service_info(string host, int port = 80) {
    printf("HTTP 서비스 정보 수집: %s:%d\n", host, port)
    dict<string, string> info = {}
    
    try {
        # HTTP 헤더 정보
        dict<string, string> headers = http_get_headers(sprintf("http://%s:%d", host, port))
        
        if (headers.contains_key("Server")) {
            info["server"] = headers["Server"]
            printf("  서버: %s\n", info["server"])
        }
        
        if (headers.contains_key("X-Powered-By")) {
            info["powered_by"] = headers["X-Powered-By"]
            printf("  구동 기술: %s\n", info["powered_by"])
        }
        
        # 웹 기술 스택 추측
        string content = http_get_content(sprintf("http://%s:%d", host, port))
        
        if (content.contains("wp-content")) {
            info["cms"] = "WordPress"
            printf("  CMS: WordPress\n")
        } else if (content.contains("Joomla")) {
            info["cms"] = "Joomla"
            printf("  CMS: Joomla\n")
        }
        
        # SSL/TLS 정보 (HTTPS 포트인 경우)
        if (port == 443) {
            dict<string, string> ssl_info = ssl_get_cert_info(host, port)
            if (ssl_info.contains_key("subject")) {
                info["ssl_subject"] = ssl_info["subject"]
                printf("  SSL 인증서 주체: %s\n", info["ssl_subject"])
            }
        }
        
    } catch (Exception ex) {
        printf("  HTTP 서비스 정보 수집 실패: %s\n", ex.get_message())
    }
    
    return info
}

# SSH 서비스 정보
function dict<string, string> ssh_service_info(string host, int port = 22) {
    printf("SSH 서비스 정보: %s:%d\n", host, port)
    dict<string, string> info = {}
    
    try {
        string ssh_version = ssh_get_version(host, port)
        if (ssh_version.length > 0) {
            info["version"] = ssh_version
            printf("  SSH 버전: %s\n", ssh_version)
            
            # SSH 알고리즘 정보
            dict<string, string[]> algorithms = ssh_get_algorithms(host, port)
            if (algorithms.contains_key("kex")) {
                printf("  키 교환 알고리즘: %s\n", array_to_string(algorithms["kex"]))
            }
        }
    } catch (Exception ex) {
        printf("  SSH 서비스 정보 수집 실패: %s\n", ex.get_message())
    }
    
    return info
}

# 서비스 정보 수집 실행
string target = "scanme.nmap.org"
banner_grab(target, 80)
http_service_info(target, 80)
ssh_service_info(target, 22)

# ============================================================================
# 3. 웹 애플리케이션 보안 테스트 (Web Application Security Testing)
# ============================================================================

print("\n\n3. 웹 애플리케이션 보안 테스트")
print("-".repeat(30))

# 디렉토리 및 파일 열거
function string[] web_directory_enum(string base_url) {
    printf("웹 디렉토리 열거: %s\n", base_url)
    
    string[] common_dirs = [
        "admin", "administrator", "backup", "config", "data",
        "db", "login", "logs", "temp", "test", "upload", "uploads"
    ]
    
    string[] found_dirs = []
    
    foreach (dir in common_dirs) {
        string url = sprintf("%s/%s", base_url, dir)
        int status_code = http_get_status(url)
        
        if (status_code == 200) {
            found_dirs.push(dir)
            printf("  발견된 디렉토리: /%s (상태: %d)\n", dir, status_code)
        } else if (status_code == 301 || status_code == 302) {
            printf("  리다이렉션: /%s (상태: %d)\n", dir, status_code)
        }
    }
    
    return found_dirs
}

# SQL 인젝션 테스트
function bool test_sql_injection(string url, string parameter) {
    printf("SQL 인젝션 테스트: %s (파라미터: %s)\n", url, parameter)
    
    string[] sqli_payloads = [
        "'",
        "' OR '1'='1",
        "' OR 1=1 --",
        "'; DROP TABLE users; --",
        "' UNION SELECT NULL --",
        "1' AND 1=1 --",
        "1' AND 1=2 --"
    ]
    
    foreach (payload in sqli_payloads) {
        try {
            string test_url = sprintf("%s?%s=%s", url, parameter, url_encode(payload))
            string response = http_get_content(test_url)
            
            # SQL 에러 패턴 검사
            if (response.contains("SQL syntax") || 
                response.contains("mysql_fetch") ||
                response.contains("ORA-") ||
                response.contains("PostgreSQL") ||
                response.contains("SQLite")) {
                
                printf("  SQL 인젝션 취약점 발견! 페이로드: %s\n", payload)
                return true
            }
            
        } catch (Exception ex) {
            printf("  테스트 중 오류: %s\n", ex.get_message())
        }
    }
    
    printf("  SQL 인젝션 취약점 없음\n")
    return false
}

# XSS 테스트
function bool test_xss(string url, string parameter) {
    printf("XSS 테스트: %s (파라미터: %s)\n", url, parameter)
    
    string[] xss_payloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg onload=alert('XSS')>",
        "'><script>alert('XSS')</script>"
    ]
    
    foreach (payload in xss_payloads) {
        try {
            string test_url = sprintf("%s?%s=%s", url, parameter, url_encode(payload))
            string response = http_get_content(test_url)
            
            if (response.contains(payload)) {
                printf("  반사형 XSS 취약점 발견! 페이로드: %s\n", payload)
                return true
            }
            
        } catch (Exception ex) {
            printf("  테스트 중 오류: %s\n", ex.get_message())
        }
    }
    
    printf("  XSS 취약점 없음\n")
    return false
}

# 웹 애플리케이션 폼 분석
function void analyze_web_forms(string url) {
    printf("웹 폼 분석: %s\n", url)
    
    try {
        string content = http_get_content(url)
        string[] forms = extract_html_forms(content)
        
        printf("  발견된 폼: %d개\n", forms.length)
        
        foreach (form in forms) {
            printf("  폼: %s\n", form)
            
            # 폼의 액션과 메서드 추출
            string action = extract_form_attribute(form, "action")
            string method = extract_form_attribute(form, "method")
            
            printf("    액션: %s, 메서드: %s\n", action, method)
            
            # 입력 필드 추출
            string[] inputs = extract_form_inputs(form)
            foreach (input in inputs) {
                printf("    입력 필드: %s\n", input)
            }
        }
        
    } catch (Exception ex) {
        printf("  웹 폼 분석 실패: %s\n", ex.get_message())
    }
}

# 웹 보안 테스트 실행
string test_url = "http://testphp.vulnweb.com"
web_directory_enum(test_url)
test_sql_injection(test_url + "/artists.php", "artist")
test_xss(test_url + "/search.php", "test")
analyze_web_forms(test_url + "/login.php")

# ============================================================================
# 4. 암호화 및 해시 크래킹 (Cryptography and Hash Cracking)
# ============================================================================

print("\n\n4. 암호화 및 해시 크래킹")
print("-".repeat(30))

# 해시 크래킹 (사전 공격)
function string crack_hash_dictionary(string hash, string hash_type, string[] dictionary) {
    printf("해시 크래킹 (사전 공격): %s (%s)\n", hash, hash_type)
    
    foreach (word in dictionary) {
        string computed_hash = ""
        
        switch (hash_type.to_lower()) {
            case "md5":
                computed_hash = hash_md5(word)
                break
            case "sha1":
                computed_hash = hash_sha1(word)
                break
            case "sha256":
                computed_hash = hash_sha256(word)
                break
            default:
                printf("지원하지 않는 해시 타입: %s\n", hash_type)
                return ""
        }
        
        if (computed_hash.to_lower() == hash.to_lower()) {
            printf("  해시 크래킹 성공! 평문: %s\n", word)
            return word
        }
    }
    
    printf("  해시 크래킹 실패 (사전에서 찾을 수 없음)\n")
    return ""
}

# 브루트포스 공격
function string crack_hash_bruteforce(string hash, string hash_type, string charset, int max_length) {
    printf("해시 크래킹 (브루트포스): %s (%s, 최대 길이: %d)\n", hash, hash_type, max_length)
    
    for (int length = 1; length <= max_length; length++) {
        printf("  길이 %d 문자열 시도 중...\n", length)
        
        # 간단한 브루트포스 시뮬레이션 (실제로는 모든 조합을 시도)
        string[] candidates = generate_combinations(charset, length, 100)  # 100개만 샘플
        
        foreach (candidate in candidates) {
            string computed_hash = ""
            
            switch (hash_type.to_lower()) {
                case "md5":
                    computed_hash = hash_md5(candidate)
                    break
                case "sha1":
                    computed_hash = hash_sha1(candidate)
                    break
                case "sha256":
                    computed_hash = hash_sha256(candidate)
                    break
            }
            
            if (computed_hash.to_lower() == hash.to_lower()) {
                printf("  브루트포스 성공! 평문: %s\n", candidate)
                return candidate
            }
        }
    }
    
    printf("  브루트포스 실패\n")
    return ""
}

# 레인보우 테이블 공격 시뮬레이션
function string rainbow_table_lookup(string hash, string hash_type) {
    printf("레인보우 테이블 조회: %s (%s)\n", hash, hash_type)
    
    # 사전에 정의된 레인보우 테이블 (시뮬레이션)
    dict<string, string> rainbow_table = {
        "5d41402abc4b2a76b9719d911017c592": "hello",      # MD5
        "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d": "hello", # SHA1
        "098f6bcd4621d373cade4e832627b4f6": "test",       # MD5
        "a94a8fe5ccb19ba61c4c0873d391e987982fbbd3": "test" # SHA1
    }
    
    if (rainbow_table.contains_key(hash.to_lower())) {
        string plaintext = rainbow_table[hash.to_lower()]
        printf("  레인보우 테이블에서 발견! 평문: %s\n", plaintext)
        return plaintext
    }
    
    printf("  레인보우 테이블에서 찾을 수 없음\n")
    return ""
}

# 암호화/복호화 테스트
function void test_encryption() {
    printf("암호화/복호화 테스트\n")
    
    string plaintext = "중요한 기밀 데이터"
    string key = "my_secret_key_123"
    
    # AES 암호화
    string aes_encrypted = aes_encrypt(plaintext, key)
    string aes_decrypted = aes_decrypt(aes_encrypted, key)
    printf("  AES 암호화: %s -> %s -> %s\n", plaintext, aes_encrypted, aes_decrypted)
    
    # DES 암호화
    string des_encrypted = des_encrypt(plaintext, key)
    string des_decrypted = des_decrypt(des_encrypted, key)
    printf("  DES 암호화: %s -> %s -> %s\n", plaintext, des_encrypted, des_decrypted)
    
    # RSA 키 쌍 생성 및 암호화
    dict<string, string> rsa_keys = rsa_generate_keypair(2048)
    string rsa_encrypted = rsa_encrypt(plaintext, rsa_keys["public"])
    string rsa_decrypted = rsa_decrypt(rsa_encrypted, rsa_keys["private"])
    printf("  RSA 암호화: %s -> %s -> %s\n", plaintext, rsa_encrypted, rsa_decrypted)
}

# 해시 크래킹 실행
string[] common_passwords = ["password", "123456", "admin", "test", "hello", "world"]
string test_hash = hash_md5("hello")  # 테스트용 해시 생성

printf("테스트 해시: %s\n", test_hash)
crack_hash_dictionary(test_hash, "md5", common_passwords)
rainbow_table_lookup(test_hash, "md5")
test_encryption()

# ============================================================================
# 5. 무선 네트워크 보안 (Wireless Network Security)
# ============================================================================

print("\n\n5. 무선 네트워크 보안")
print("-".repeat(30))

# WiFi 네트워크 스캔
function dict<string, mixed>[] wifi_scan() {
    printf("WiFi 네트워크 스캔\n")
    
    # 시뮬레이션된 WiFi 네트워크 목록
    dict<string, mixed>[] networks = [
        {"ssid": "HomeNetwork", "bssid": "aa:bb:cc:dd:ee:ff", "security": "WPA2", "signal": -45, "channel": 6},
        {"ssid": "OfficeWiFi", "bssid": "11:22:33:44:55:66", "security": "WPA3", "signal": -60, "channel": 11},
        {"ssid": "OpenWiFi", "bssid": "77:88:99:aa:bb:cc", "security": "Open", "signal": -35, "channel": 1},
        {"ssid": "HiddenNetwork", "bssid": "dd:ee:ff:00:11:22", "security": "WEP", "signal": -70, "channel": 3}
    ]
    
    printf("발견된 WiFi 네트워크:\n")
    foreach (network in networks) {
        printf("  SSID: %s, BSSID: %s, 보안: %s, 신호: %d dBm, 채널: %d\n",
               network["ssid"], network["bssid"], network["security"], 
               network["signal"], network["channel"])
    }
    
    return networks
}

# WPS 핀 브루트포스
function bool wps_pin_bruteforce(string bssid, string target_ssid) {
    printf("WPS 핀 브루트포스: %s (%s)\n", target_ssid, bssid)
    
    # 일반적인 WPS 핀들
    string[] common_pins = ["12345670", "00000000", "11111111", "12345678"]
    
    foreach (pin in common_pins) {
        printf("  핀 시도: %s\n", pin)
        
        # WPS 핀 검증 시뮬레이션
        if (pin == "12345670") {  # 시뮬레이션: 첫 번째 핀이 맞다고 가정
            printf("  WPS 핀 발견! 핀: %s\n", pin)
            return true
        }
    }
    
    printf("  WPS 핀 브루트포스 실패\n")
    return false
}

# WEP 키 크래킹 시뮬레이션
function string wep_key_crack(string bssid, string target_ssid) {
    printf("WEP 키 크래킹: %s (%s)\n", target_ssid, bssid)
    printf("  IV 패킷 수집 중...\n")
    
    # 시뮬레이션: IV 패킷 수집
    for (int i = 0; i < 50000; i += 10000) {
        printf("  수집된 IV: %d개\n", i)
        sleep(500)  # 500ms 대기
    }
    
    printf("  충분한 IV 수집 완료, 키 크래킹 시작...\n")
    string cracked_key = "1234567890"  # 시뮬레이션된 크래킹 결과
    printf("  WEP 키 크래킹 성공! 키: %s\n", cracked_key)
    
    return cracked_key
}

# 무선 네트워크 보안 테스트 실행
dict<string, mixed>[] wifi_networks = wifi_scan()

foreach (network in wifi_networks) {
    string ssid = network["ssid"]
    string bssid = network["bssid"]
    string security = network["security"]
    
    printf("\n네트워크 %s 보안 테스트:\n", ssid)
    
    if (security == "WEP") {
        wep_key_crack(bssid, ssid)
    } else if (security == "WPA2" || security == "WPA3") {
        printf("  WPA 핸드셰이크 캡처 시도...\n")
        # WPA 핸드셰이크 캡처 시뮬레이션
    } else if (security == "Open") {
        printf("  개방된 네트워크 - 보안 없음\n")
    }
    
    # WPS 테스트
    printf("  WPS 활성화 확인...\n")
    if (random_bool()) {  # 랜덤하게 WPS 활성화 여부 결정
        wps_pin_bruteforce(bssid, ssid)
    } else {
        printf("  WPS 비활성화됨\n")
    }
}

# ============================================================================
# 6. 포렌식 및 데이터 복구 (Forensics and Data Recovery)
# ============================================================================

print("\n\n6. 포렌식 및 데이터 복구")
print("-".repeat(30))

# 파일 메타데이터 분석
function dict<string, mixed> analyze_file_metadata(string file_path) {
    printf("파일 메타데이터 분석: %s\n", file_path)
    
    dict<string, mixed> metadata = {}
    
    try {
        # 파일 기본 정보
        metadata["size"] = file_get_size(file_path)
        metadata["created"] = file_get_creation_time(file_path)
        metadata["modified"] = file_get_modification_time(file_path)
        metadata["accessed"] = file_get_access_time(file_path)
        
        # 파일 해시
        metadata["md5"] = file_hash_md5(file_path)
        metadata["sha1"] = file_hash_sha1(file_path)
        metadata["sha256"] = file_hash_sha256(file_path)
        
        # EXIF 데이터 (이미지 파일인 경우)
        if (file_path.ends_with(".jpg") || file_path.ends_with(".jpeg") || file_path.ends_with(".png")) {
            dict<string, string> exif = extract_exif_data(file_path)
            metadata["exif"] = exif
        }
        
        printf("  크기: %d 바이트\n", metadata["size"])
        printf("  생성일: %s\n", metadata["created"])
        printf("  MD5: %s\n", metadata["md5"])
        
    } catch (Exception ex) {
        printf("  메타데이터 분석 실패: %s\n", ex.get_message())
    }
    
    return metadata
}

# 삭제된 파일 복구 시뮬레이션
function string[] recover_deleted_files(string drive_path) {
    printf("삭제된 파일 복구: %s\n", drive_path)
    
    # 시뮬레이션된 삭제된 파일 목록
    string[] deleted_files = [
        "deleted_document.txt",
        "removed_image.jpg",
        "old_log.log",
        "temp_file.tmp"
    ]
    
    string[] recovered_files = []
    
    foreach (file in deleted_files) {
        printf("  파일 복구 시도: %s\n", file)
        
        # 복구 성공률 시뮬레이션 (70% 확률로 성공)
        if (random_int(1, 10) <= 7) {
            recovered_files.push(file)
            printf("    복구 성공!\n")
        } else {
            printf("    복구 실패 (덮어쓰여짐)\n")
        }
    }
    
    printf("총 %d개 파일 중 %d개 복구됨\n", deleted_files.length, recovered_files.length)
    return recovered_files
}

# 네트워크 트래픽 분석
function void analyze_network_traffic(string pcap_file) {
    printf("네트워크 트래픽 분석: %s\n", pcap_file)
    
    # 시뮬레이션된 패킷 분석 결과
    dict<string, int> protocol_stats = {
        "HTTP": 145,
        "HTTPS": 89,
        "DNS": 67,
        "TCP": 234,
        "UDP": 123,
        "ICMP": 12
    }
    
    printf("  프로토콜 통계:\n")
    foreach (protocol, count in protocol_stats) {
        printf("    %s: %d 패킷\n", protocol, count)
    }
    
    # 의심스러운 트래픽 탐지
    string[] suspicious_ips = ["192.168.1.666", "10.0.0.999", "172.16.1.333"]
    printf("  의심스러운 IP 주소:\n")
    foreach (ip in suspicious_ips) {
        printf("    %s (비정상적인 트래픽 패턴)\n", ip)
    }
    
    # 암호화되지 않은 자격 증명 탐지
    printf("  발견된 평문 자격 증명:\n")
    printf("    사용자명: admin, 비밀번호: password123\n")
    printf("    사용자명: user, 비밀번호: 123456\n")
}

# 메모리 덤프 분석
function void analyze_memory_dump(string dump_file) {
    printf("메모리 덤프 분석: %s\n", dump_file)
    
    # 시뮬레이션된 메모리 분석 결과
    printf("  실행 중인 프로세스:\n")
    string[] processes = ["explorer.exe", "chrome.exe", "notepad.exe", "malware.exe", "svchost.exe"]
    foreach (process in processes) {
        printf("    %s\n", process)
        if (process == "malware.exe") {
            printf("      [경고] 의심스러운 프로세스 발견!\n")
        }
    }
    
    printf("  네트워크 연결:\n")
    printf("    192.168.1.100:1234 -> 10.0.0.1:80 (의심스러운 외부 연결)\n")
    printf("    127.0.0.1:3389 -> 0.0.0.0:0 (RDP 리스너)\n")
    
    printf("  발견된 비밀번호:\n")
    printf("    Windows 로그인: user123/pass456\n")
    printf("    브라우저 저장된 비밀번호: admin/secret\n")
}

# 포렌식 분석 실행
string test_file = "./test_image.jpg"
if (!file_exists(test_file)) {
    file_write(test_file, "fake image data")  # 테스트용 파일 생성
}

analyze_file_metadata(test_file)
recover_deleted_files("/")
analyze_network_traffic("captured_traffic.pcap")
analyze_memory_dump("memory_dump.dmp")

# ============================================================================
# 7. 악성코드 분석 (Malware Analysis)
# ============================================================================

print("\n\n7. 악성코드 분석")
print("-".repeat(30))

# 정적 분석
function dict<string, mixed> static_malware_analysis(string file_path) {
    printf("정적 악성코드 분석: %s\n", file_path)
    dict<string, mixed> analysis = {}
    
    # 파일 해시 계산
    analysis["md5"] = file_hash_md5(file_path)
    analysis["sha1"] = file_hash_sha1(file_path)
    analysis["sha256"] = file_hash_sha256(file_path)
    
    printf("  MD5: %s\n", analysis["md5"])
    printf("  SHA1: %s\n", analysis["sha1"])
    printf("  SHA256: %s\n", analysis["sha256"])
    
    # 바이러스 토탈 조회 시뮬레이션
    printf("  바이러스 토탈 조회...\n")
    int detection_count = random_int(0, 45)
    analysis["vt_detection"] = detection_count
    printf("    탐지: %d/68 엔진\n", detection_count)
    
    # 문자열 추출
    string[] strings = extract_strings(file_path)
    analysis["strings"] = strings
    printf("  추출된 문자열: %d개\n", strings.length)
    
    # 의심스러운 문자열 탐지
    string[] suspicious_strings = []
    string[] malware_indicators = ["cmd.exe", "powershell", "regedit", "keylogger", "backdoor"]
    
    foreach (str in strings) {
        foreach (indicator in malware_indicators) {
            if (str.to_lower().contains(indicator)) {
                suspicious_strings.push(str)
            }
        }
    }
    
    if (suspicious_strings.length > 0) {
        printf("  의심스러운 문자열 발견:\n")
        foreach (sus_str in suspicious_strings) {
            printf("    %s\n", sus_str)
        }
    }
    
    return analysis
}

# 동적 분석 (샌드박스)
function dict<string, mixed> dynamic_malware_analysis(string file_path) {
    printf("동적 악성코드 분석 (샌드박스): %s\n", file_path)
    dict<string, mixed> analysis = {}
    
    printf("  샌드박스 환경에서 실행 중...\n")
    sleep(2000)  # 2초 대기 (분석 시뮬레이션)
    
    # 네트워크 활동
    string[] network_connections = [
        "연결: 192.168.1.100:1234 -> 88.99.100.101:80",
        "DNS 조회: malicious-domain.com",
        "HTTP 요청: GET /download/payload.exe"
    ]
    analysis["network_activity"] = network_connections
    
    printf("  네트워크 활동:\n")
    foreach (conn in network_connections) {
        printf("    %s\n", conn)
    }
    
    # 파일 시스템 변경
    string[] file_changes = [
        "생성: C:\\Windows\\Temp\\malware.exe",
        "수정: HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        "삭제: C:\\Users\\User\\Desktop\\important.txt"
    ]
    analysis["file_changes"] = file_changes
    
    printf("  파일 시스템 변경:\n")
    foreach (change in file_changes) {
        printf("    %s\n", change)
    }
    
    # 프로세스 활동
    string[] process_activity = [
        "프로세스 생성: notepad.exe (위장)",
        "프로세스 주입: explorer.exe에 코드 주입",
        "권한 상승 시도"
    ]
    analysis["process_activity"] = process_activity
    
    printf("  프로세스 활동:\n")
    foreach (activity in process_activity) {
        printf("    %s\n", activity)
    }
    
    return analysis
}

# YARA 규칙 매칭
function bool yara_scan(string file_path, string[] yara_rules) {
    printf("YARA 규칙 스캔: %s\n", file_path)
    
    bool match_found = false
    
    foreach (rule in yara_rules) {
        printf("  규칙 확인: %s\n", rule)
        
        # 시뮬레이션: 일부 규칙과 매치
        if (rule.contains("trojan") || rule.contains("keylogger")) {
            printf("    매치! 악성코드 탐지\n")
            match_found = true
        } else {
            printf("    매치 없음\n")
        }
    }
    
    return match_found
}

# 악성코드 분석 실행
string malware_sample = "./suspicious_file.exe"
if (!file_exists(malware_sample)) {
    file_write(malware_sample, "fake malware sample")  # 테스트용 파일 생성
}

static_malware_analysis(malware_sample)
dynamic_malware_analysis(malware_sample)

string[] yara_rules = ["trojan_generic", "keylogger_detection", "ransomware_indicators"]
yara_scan(malware_sample, yara_rules)

# ============================================================================
# 8. 보고서 생성 및 정리 (Report Generation and Cleanup)
# ============================================================================

print("\n\n8. 보고서 생성 및 정리")
print("-".repeat(30))

# 보안 평가 보고서 생성
function void generate_security_report() {
    printf("보안 평가 보고서 생성 중...\n")
    
    string report_content = sprintf("""
# PSP 보안 평가 보고서
생성일: %s

## 실행된 테스트
- 네트워크 정찰 및 스캔
- 서비스 및 버전 탐지
- 웹 애플리케이션 보안 테스트
- 암호화 및 해시 크래킹
- 무선 네트워크 보안
- 포렌식 및 데이터 복구
- 악성코드 분석

## 발견된 취약점
1. 열린 포트: 22, 80, 443
2. 웹 애플리케이션 취약점: SQL 인젝션 가능성
3. 약한 암호화: WEP 사용
4. 의심스러운 파일: malware.exe

## 권장사항
1. 불필요한 서비스 비활성화
2. 웹 애플리케이션 입력 검증 강화
3. WPA3 암호화로 업그레이드
4. 엔드포인트 보안 솔루션 도입

## 상세 분석 결과
[상세 분석 데이터는 별도 첨부 파일 참조]
""", get_current_time().to_string())
    
    string report_file = "./security_assessment_report.md"
    file_write(report_file, report_content)
    printf("보고서 저장됨: %s\n", report_file)
}

# 임시 파일 정리
function void cleanup_temp_files() {
    printf("임시 파일 정리 중...\n")
    
    string[] temp_files = [
        "./test_image.jpg",
        "./suspicious_file.exe",
        "./security_assessment_report.md"
    ]
    
    foreach (file in temp_files) {
        if (file_exists(file)) {
            file_delete(file)
            printf("  삭제됨: %s\n", file)
        }
    }
}

# 보고서 생성 및 정리 실행
generate_security_report()

print("\n" + "=".repeat(50))
print("PSP 보안 및 해킹 도구 종합 예제 완료!")
print("이 예제는 다음을 포함합니다:")
print("- 네트워크 정찰 및 포트 스캔")
print("- 서비스 탐지 및 배너 그래빙")
print("- 웹 애플리케이션 보안 테스트")
print("- 암호화 및 해시 크래킹")
print("- 무선 네트워크 보안 테스트")
print("- 디지털 포렌식")
print("- 악성코드 분석")
print("- 보안 평가 보고서 생성")
print("=".repeat(50))

# 정리
cleanup_temp_files()
print("\n프로그램 종료 - 모든 임시 파일이 정리되었습니다.")
