#!/usr/bin/env psp
# -*- coding: utf-8 -*-

/**
 * PSP 언어 종합 기능 데모
 * 모든 언어 기능을 포함한 완전한 예제
 * Features: 변수, 타입, 제어구조, 함수, 클래스, 예외처리, 모듈, 비동기, 메타프로그래밍
 */

# ============================================================================
# 1. 변수와 데이터 타입 (Variables and Data Types)
# ============================================================================

print("=== 1. 변수와 데이터 타입 ===")

# 기본 변수 선언
string name = "PSP Language"
int version = 1
float pi = 3.14159
bool is_secure = true
char grade = 'A'

# 타입 추론
auto inferred_int = 42
auto inferred_string = "자동 타입 추론"
var dynamic_var = "동적 타입"

# 상수
const string LANGUAGE_NAME = "PSP"
const int MAX_CONNECTIONS = 100
readonly datetime NOW = get_current_time()

printf("언어: %s, 버전: %d, 파이: %.2f\n", name, version, pi)
printf("보안: %s, 등급: %c\n", is_secure ? "예" : "아니오", grade)

# ============================================================================
# 2. 배열과 컬렉션 (Arrays and Collections)
# ============================================================================

print("\n=== 2. 배열과 컬렉션 ===")

# 배열 선언
int[] numbers = [1, 2, 3, 4, 5]
string[] fruits = ["apple", "banana", "cherry"]
mixed[] mixed_array = [1, "text", 3.14, true]

# 동적 배열
dynamic_array<string> hosts = new dynamic_array<string>()
hosts.push("192.168.1.1")
hosts.push("google.com")
hosts.push("github.com")

# 딕셔너리/맵
dict<string, int> port_map = {
    "http": 80,
    "https": 443,
    "ssh": 22,
    "ftp": 21
}

# 리스트 (Python 스타일)
list<string> vulnerabilities = ["SQLi", "XSS", "CSRF", "Buffer Overflow"]

# 세트
set<string> unique_ips = {"192.168.1.1", "10.0.0.1", "172.16.0.1"}

# 배열 연산
printf("숫자 배열: %s\n", array_to_string(numbers))
printf("과일 개수: %d\n", fruits.length)
printf("HTTP 포트: %d\n", port_map["http"])

# 배열 순회
print("취약점 목록:")
foreach (vuln in vulnerabilities) {
    printf("- %s\n", vuln)
}

# ============================================================================
# 3. 제어 구조 (Control Structures)
# ============================================================================

print("\n=== 3. 제어 구조 ===")

# if-else 문
int target_port = 80
if (target_port == 80) {
    print("HTTP 포트 스캔")
} else if (target_port == 443) {
    print("HTTPS 포트 스캔")
} else {
    printf("사용자 정의 포트 %d 스캔\n", target_port)
}

# 삼항 연산자
string service = (target_port == 22) ? "SSH" : "Unknown"
printf("서비스: %s\n", service)

# switch 문
switch (target_port) {
    case 21:
        print("FTP 서비스")
        break
    case 22:
        print("SSH 서비스")
        break
    case 80:
        print("HTTP 서비스")
        break
    case 443:
        print("HTTPS 서비스")
        break
    default:
        print("알 수 없는 서비스")
        break
}

# for 루프
print("포트 스캔 시뮬레이션:")
for (int port = 80; port <= 85; port++) {
    printf("포트 %d 스캔 중...\n", port)
    if (port == 83) {
        print("포트 83 건너뛰기")
        continue
    }
    if (port == 85) {
        print("스캔 중단")
        break
    }
}

# while 루프
int attempts = 0
while (attempts < 3) {
    printf("연결 시도 %d\n", attempts + 1)
    attempts++
}

# do-while 루프
int retry = 0
do {
    printf("재시도 %d\n", retry + 1)
    retry++
} while (retry < 2)

# foreach 루프
print("대상 호스트:")
foreach (host in hosts) {
    printf("- %s\n", host)
}

# range 기반 루프
print("범위 기반 루프:")
for (i in range(1, 5)) {
    printf("인덱스: %d\n", i)
}

# ============================================================================
# 4. 함수 (Functions)
# ============================================================================

print("\n=== 4. 함수 ===")

# 기본 함수
function greet(string name) {
    return sprintf("안녕하세요, %s님!", name)
}

# 타입이 명시된 함수
function int add(int a, int b) -> int {
    return a + b
}

# 기본 매개변수
function string format_ip(string ip, bool show_port = false, int port = 80) {
    if (show_port) {
        return sprintf("%s:%d", ip, port)
    }
    return ip
}

# 가변 매개변수
function float average(params float[] numbers) {
    float sum = 0
    foreach (num in numbers) {
        sum += num
    }
    return sum / numbers.length
}

# 람다 함수
auto square = (int x) => x * x
auto is_even = (int n) => n % 2 == 0

# 고차 함수
function int apply_operation(int x, int y, function<int, int, int> op) {
    return op(x, y)
}

# 재귀 함수
function long factorial(int n) {
    if (n <= 1) return 1
    return n * factorial(n - 1)
}

# 함수 호출
printf("%s\n", greet("해커"))
printf("5 + 3 = %d\n", add(5, 3))
printf("IP 주소: %s\n", format_ip("192.168.1.1", true, 8080))
printf("평균: %.2f\n", average(1.0, 2.0, 3.0, 4.0, 5.0))
printf("5의 제곱: %d\n", square(5))
printf("4는 짝수인가? %s\n", is_even(4) ? "예" : "아니오")
printf("팩토리얼 5! = %ld\n", factorial(5))

# ============================================================================
# 5. 클래스와 객체 지향 프로그래밍 (Classes and OOP)
# ============================================================================

print("\n=== 5. 클래스와 객체 지향 ===")

# 기본 클래스
class NetworkScanner {
    # 멤버 변수
    private string target_ip
    private int timeout
    protected bool verbose
    public list<int> open_ports
    
    # 생성자
    constructor(string ip, int timeout_sec = 5) {
        this.target_ip = ip
        this.timeout = timeout_sec
        this.verbose = false
        this.open_ports = new list<int>()
    }
    
    # 멤버 함수
    public void set_verbose(bool enable) {
        this.verbose = enable
    }
    
    public bool scan_port(int port) {
        if (this.verbose) {
            printf("포트 %d 스캔 중...\n", port)
        }
        
        # 실제 포트 스캔 시뮬레이션
        bool is_open = (port % 2 == 0)  # 짝수 포트만 열린 것으로 가정
        
        if (is_open) {
            this.open_ports.push(port)
        }
        
        return is_open
    }
    
    public void scan_range(int start_port, int end_port) {
        printf("%s의 포트 %d-%d 스캔 시작\n", this.target_ip, start_port, end_port)
        
        for (int port = start_port; port <= end_port; port++) {
            if (this.scan_port(port)) {
                printf("포트 %d: 열림\n", port)
            }
        }
    }
    
    # getter/setter
    public string get_target() {
        return this.target_ip
    }
    
    public int get_open_port_count() {
        return this.open_ports.length
    }
    
    # 정적 메서드
    static bool is_valid_ip(string ip) {
        # 간단한 IP 유효성 검사
        string[] parts = ip.split(".")
        return parts.length == 4
    }
    
    # 소멸자
    destructor() {
        printf("NetworkScanner 객체 해제: %s\n", this.target_ip)
    }
}

# 상속
class AdvancedScanner : NetworkScanner {
    private string scan_type
    
    constructor(string ip, string type = "tcp") : super(ip, 10) {
        this.scan_type = type
    }
    
    # 메서드 오버라이드
    override public bool scan_port(int port) {
        printf("[%s] 고급 스캔: 포트 %d\n", this.scan_type, port)
        return super.scan_port(port)  # 부모 메서드 호출
    }
    
    # 새로운 메서드
    public void stealth_scan(int port) {
        printf("스텔스 스캔: 포트 %d\n", port)
        # 스텔스 스캔 로직
    }
}

# 추상 클래스
abstract class Exploit {
    protected string target
    protected int severity
    
    constructor(string target_host) {
        this.target = target_host
        this.severity = 0
    }
    
    # 추상 메서드
    abstract bool execute()
    abstract string get_description()
    
    # 구현된 메서드
    public int get_severity() {
        return this.severity
    }
}

# 추상 클래스 구현
class SQLInjectionExploit : Exploit {
    private string payload
    
    constructor(string target_host, string sql_payload) : super(target_host) {
        this.payload = sql_payload
        this.severity = 8  # 높은 위험도
    }
    
    override bool execute() {
        printf("SQL 인젝션 실행: %s -> %s\n", this.target, this.payload)
        return true
    }
    
    override string get_description() {
        return "SQL 인젝션 취약점 익스플로잇"
    }
}

# 인터페이스
interface Encryptable {
    string encrypt(string data)
    string decrypt(string encrypted_data)
}

# 인터페이스 구현
class AESCrypto : Encryptable {
    private string key
    
    constructor(string encryption_key) {
        this.key = encryption_key
    }
    
    override string encrypt(string data) {
        return sprintf("AES_ENCRYPTED[%s]", data)  # 단순화된 구현
    }
    
    override string decrypt(string encrypted_data) {
        return encrypted_data.replace("AES_ENCRYPTED[", "").replace("]", "")
    }
}

# 객체 생성 및 사용
NetworkScanner scanner = new NetworkScanner("192.168.1.100")
scanner.set_verbose(true)
scanner.scan_range(80, 85)
printf("발견된 열린 포트 수: %d\n", scanner.get_open_port_count())

AdvancedScanner adv_scanner = new AdvancedScanner("10.0.0.1", "syn")
adv_scanner.stealth_scan(22)

SQLInjectionExploit sqli = new SQLInjectionExploit("target.com", "' OR 1=1 --")
printf("익스플로잇 설명: %s\n", sqli.get_description())
printf("실행 결과: %s\n", sqli.execute() ? "성공" : "실패")

AESCrypto crypto = new AESCrypto("my_secret_key")
string encrypted = crypto.encrypt("비밀 데이터")
string decrypted = crypto.decrypt(encrypted)
printf("암호화: %s -> 복호화: %s\n", encrypted, decrypted)

# ============================================================================
# 6. 예외 처리 (Exception Handling)
# ============================================================================

print("\n=== 6. 예외 처리 ===")

# 사용자 정의 예외
class NetworkException : Exception {
    private string host
    
    constructor(string message, string target_host) : super(message) {
        this.host = target_host
    }
    
    public string get_host() {
        return this.host
    }
}

class TimeoutException : NetworkException {
    constructor(string host) : super("연결 시간 초과", host) {}
}

# 예외 처리 함수
function void risky_network_operation(string host) {
    if (host == "bad.host.com") {
        throw new NetworkException("악성 호스트 감지", host)
    }
    if (host == "slow.host.com") {
        throw new TimeoutException(host)
    }
    printf("성공적으로 연결: %s\n", host)
}

# try-catch 블록
string[] test_hosts = ["good.host.com", "bad.host.com", "slow.host.com"]

foreach (host in test_hosts) {
    try {
        risky_network_operation(host)
    } catch (TimeoutException ex) {
        printf("시간 초과 예외: %s (%s)\n", ex.get_message(), ex.get_host())
    } catch (NetworkException ex) {
        printf("네트워크 예외: %s (%s)\n", ex.get_message(), ex.get_host())
    } catch (Exception ex) {
        printf("일반 예외: %s\n", ex.get_message())
    } finally {
        printf("호스트 %s 테스트 완료\n", host)
    }
}

# ============================================================================
# 7. 모듈과 네임스페이스 (Modules and Namespaces)
# ============================================================================

print("\n=== 7. 모듈과 네임스페이스 ===")

# 네임스페이스
namespace Security {
    namespace Crypto {
        function string simple_hash(string input) {
            return sprintf("HASH_%s", input.to_upper())
        }
        
        class SimpleEncoder {
            static string encode(string data) {
                return sprintf("ENCODED_%s", data)
            }
        }
    }
    
    namespace Network {
        const int DEFAULT_TIMEOUT = 30
        
        function bool ping(string host) {
            printf("핑 테스트: %s\n", host)
            return true
        }
    }
}

# 네임스페이스 사용
string hashed = Security.Crypto.simple_hash("password123")
printf("해시된 비밀번호: %s\n", hashed)

string encoded = Security.Crypto.SimpleEncoder.encode("secret data")
printf("인코딩된 데이터: %s\n", encoded)

bool ping_result = Security.Network.ping("google.com")
printf("핑 결과: %s\n", ping_result ? "성공" : "실패")

# using 선언
using Security.Network
printf("기본 타임아웃: %d초\n", DEFAULT_TIMEOUT)

# ============================================================================
# 8. 제네릭 프로그래밍 (Generic Programming)
# ============================================================================

print("\n=== 8. 제네릭 프로그래밍 ===")

# 제네릭 클래스
class Stack<T> {
    private list<T> items
    
    constructor() {
        this.items = new list<T>()
    }
    
    public void push(T item) {
        this.items.push(item)
    }
    
    public T pop() {
        if (this.items.length == 0) {
            throw new Exception("스택이 비어있습니다")
        }
        T item = this.items[this.items.length - 1]
        this.items.remove_at(this.items.length - 1)
        return item
    }
    
    public bool is_empty() {
        return this.items.length == 0
    }
    
    public int size() {
        return this.items.length
    }
}

# 제네릭 함수
function T find_max<T>(T[] array) where T : IComparable<T> {
    if (array.length == 0) {
        throw new Exception("빈 배열입니다")
    }
    
    T max = array[0]
    for (int i = 1; i < array.length; i++) {
        if (array[i] > max) {
            max = array[i]
        }
    }
    return max
}

# 제네릭 사용
Stack<string> string_stack = new Stack<string>()
string_stack.push("첫 번째")
string_stack.push("두 번째")
string_stack.push("세 번째")

printf("스택 크기: %d\n", string_stack.size())
while (!string_stack.is_empty()) {
    printf("팝: %s\n", string_stack.pop())
}

int[] int_array = [3, 7, 1, 9, 5]
printf("최대값: %d\n", find_max<int>(int_array))

# ============================================================================
# 9. 비동기 프로그래밍 (Asynchronous Programming)
# ============================================================================

print("\n=== 9. 비동기 프로그래밍 ===")

# 비동기 함수
async function string download_content(string url) {
    printf("다운로드 시작: %s\n", url)
    await sleep(1000)  # 1초 대기 (시뮬레이션)
    return sprintf("내용: %s에서 다운로드됨", url)
}

async function void scan_multiple_hosts(string[] hosts) {
    list<Task<string>> tasks = new list<Task<string>>()
    
    # 병렬로 여러 호스트 스캔 시작
    foreach (host in hosts) {
        Task<string> task = download_content(sprintf("http://%s", host))
        tasks.push(task)
    }
    
    # 모든 작업 완료 대기
    foreach (task in tasks) {
        string result = await task
        printf("결과: %s\n", result)
    }
}

# 비동기 실행
string[] target_hosts = ["example.com", "google.com", "github.com"]
Task<void> scan_task = scan_multiple_hosts(target_hosts)

# Task.WaitAll을 사용하여 모든 작업 완료 대기
Task.wait_all([scan_task])

# ============================================================================
# 10. 메타프로그래밍과 리플렉션 (Metaprogramming and Reflection)
# ============================================================================

print("\n=== 10. 메타프로그래밍과 리플렉션 ===")

# 어트리뷰트 정의
attribute DebugInfo {
    string author
    string version
    datetime created
    
    constructor(string author_name, string ver) {
        this.author = author_name
        this.version = ver
        this.created = get_current_time()
    }
}

# 어트리뷰트 사용
[DebugInfo("WhiteHat Hacker", "1.0")]
class VulnerabilityScanner {
    [Deprecated("Use scan_advanced instead")]
    public void scan_basic(string target) {
        printf("기본 스캔: %s\n", target)
    }
    
    public void scan_advanced(string target) {
        printf("고급 스캔: %s\n", target)
    }
}

# 리플렉션 사용
Type scanner_type = typeof(VulnerabilityScanner)
printf("클래스 이름: %s\n", scanner_type.get_name())

# 어트리뷰트 정보 가져오기
DebugInfo[] debug_attrs = scanner_type.get_attributes<DebugInfo>()
if (debug_attrs.length > 0) {
    DebugInfo info = debug_attrs[0]
    printf("작성자: %s, 버전: %s\n", info.author, info.version)
}

# 메서드 정보
Method[] methods = scanner_type.get_methods()
foreach (method in methods) {
    printf("메서드: %s\n", method.get_name())
    
    # Deprecated 어트리뷰트 확인
    if (method.has_attribute<Deprecated>()) {
        printf("  (사용 중단됨)\n")
    }
}

# 런타임에 객체 생성
object scanner_instance = Activator.create_instance(scanner_type)
VulnerabilityScanner scanner_obj = (VulnerabilityScanner)scanner_instance

# 런타임에 메서드 호출
Method scan_method = scanner_type.get_method("scan_advanced")
scan_method.invoke(scanner_obj, ["target.example.com"])

# ============================================================================
# 11. 매크로와 코드 생성 (Macros and Code Generation)
# ============================================================================

print("\n=== 11. 매크로와 코드 생성 ===")

# 간단한 매크로
macro LOG(message) {
    printf("[%s] %s\n", get_current_time().to_string(), message)
}

# 조건부 컴파일 매크로
macro DEBUG_PRINT(message) {
    #if DEBUG
        printf("DEBUG: %s\n", message)
    #endif
}

# 반복 코드 생성 매크로
macro DEFINE_GETTER_SETTER(type, name) {
    private type _##name;
    
    public type get_##name() {
        return this._##name;
    }
    
    public void set_##name(type value) {
        this._##name = value;
    }
}

# 매크로 사용 예제
class Configuration {
    DEFINE_GETTER_SETTER(string, host)
    DEFINE_GETTER_SETTER(int, port)
    DEFINE_GETTER_SETTER(bool, ssl_enabled)
}

# 매크로 호출
LOG("프로그램 시작")
DEBUG_PRINT("디버그 정보")

Configuration config = new Configuration()
config.set_host("secure.example.com")
config.set_port(443)
config.set_ssl_enabled(true)

printf("설정 - 호스트: %s, 포트: %d, SSL: %s\n", 
       config.get_host(), config.get_port(), 
       config.get_ssl_enabled() ? "활성화" : "비활성화")

# ============================================================================
# 12. 고급 PSP 기능 (Advanced PSP Features)
# ============================================================================

print("\n=== 12. 고급 PSP 기능 ===")

# PowerShell 스타일 파이프라인
string[] log_lines = ["INFO: 시작", "ERROR: 실패", "INFO: 재시도", "SUCCESS: 완료"]

log_lines 
    | where { $_.contains("ERROR") }
    | select { $_.to_upper() }
    | foreach { printf("필터링됨: %s\n", $_) }

# 정규식 연산자
string test_ip = "192.168.1.100"
if (test_ip =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) {
    printf("%s는 유효한 IP 주소입니다\n", test_ip)
}

# 문자열 보간
string target_host = "example.com"
int target_port = 80
string connection_string = $"연결 대상: {target_host}:{target_port}"
printf("%s\n", connection_string)

# 범위 연산자
int[] range_1_to_10 = 1..10
int[] even_numbers = range_1_to_10 | where { $_ % 2 == 0 }

printf("1부터 10까지: %s\n", array_to_string(range_1_to_10))
printf("짝수만: %s\n", array_to_string(even_numbers))

# PSP 내장 보안 함수 사용
print("\n--- PSP 내장 보안 함수 ---")

# 네트워크 스캔
dict<string, mixed> scan_result = port_scan("scanme.nmap.org", [80, 443, 22])
printf("포트 스캔 결과: %s\n", dict_to_string(scan_result))

# 해시 생성
string password = "test123"
string md5_hash = hash_md5(password)
string sha256_hash = hash_sha256(password)
printf("MD5: %s\n", md5_hash)
printf("SHA256: %s\n", sha256_hash)

# Base64 인코딩/디코딩
string original_data = "중요한 데이터"
string encoded_data = base64_encode(original_data)
string decoded_data = base64_decode(encoded_data)
printf("원본: %s -> 인코딩: %s -> 디코딩: %s\n", original_data, encoded_data, decoded_data)

# SQL 인젝션 테스트
string[] sqli_payloads = ["' OR 1=1 --", "'; DROP TABLE users; --", "' UNION SELECT * FROM passwords --"]
foreach (payload in sqli_payloads) {
    printf("SQL 인젝션 페이로드 테스트: %s\n", payload)
}

# XSS 페이로드 생성
string xss_payload = generate_xss_payload("alert", "XSS 테스트")
printf("XSS 페이로드: %s\n", xss_payload)

# ============================================================================
# 13. 파일 및 시스템 조작 (File and System Operations)
# ============================================================================

print("\n=== 13. 파일 및 시스템 조작 ===")

# 파일 읽기/쓰기
string test_file = "./test_output.txt"
string content = "PSP 언어 테스트 파일\n생성 시간: " + get_current_time().to_string()

file_write(test_file, content)
printf("파일 작성 완료: %s\n", test_file)

if (file_exists(test_file)) {
    string read_content = file_read(test_file)
    printf("파일 내용:\n%s\n", read_content)
}

# 디렉토리 조작
string test_dir = "./test_directory"
if (!dir_exists(test_dir)) {
    dir_create(test_dir)
    printf("디렉토리 생성: %s\n", test_dir)
}

# 시스템 정보
printf("운영체제: %s\n", get_os_info())
printf("현재 사용자: %s\n", get_current_user())
printf("작업 디렉토리: %s\n", get_current_directory())

# 환경 변수
string home_dir = get_env_var("HOME") ?: get_env_var("USERPROFILE") ?: "알 수 없음"
printf("홈 디렉토리: %s\n", home_dir)

# 프로세스 실행 (안전한 명령어만)
string ping_result = execute_command("ping -c 1 google.com")
printf("핑 결과: %s\n", ping_result)

# ============================================================================
# 14. 성능 측정 및 프로파일링 (Performance and Profiling)
# ============================================================================

print("\n=== 14. 성능 측정 ===")

# 시간 측정
Stopwatch sw = new Stopwatch()
sw.start()

# 성능 테스트할 작업
int sum = 0
for (int i = 0; i < 1000000; i++) {
    sum += i
}

sw.stop()
printf("백만 번 반복 계산 시간: %d ms\n", sw.elapsed_milliseconds())
printf("계산 결과: %d\n", sum)

# 메모리 사용량
printf("현재 메모리 사용량: %d KB\n", get_memory_usage())

# ============================================================================
# 15. 정리 및 마무리 (Cleanup)
# ============================================================================

print("\n=== 15. 프로그램 마무리 ===")

# 생성된 테스트 파일 정리
if (file_exists(test_file)) {
    file_delete(test_file)
    printf("테스트 파일 삭제: %s\n", test_file)
}

if (dir_exists(test_dir)) {
    dir_delete(test_dir)
    printf("테스트 디렉토리 삭제: %s\n", test_dir)
}

LOG("PSP 종합 기능 데모 완료")

print("\n" + "=".repeat(50))
print("PSP 언어의 모든 주요 기능을 시연했습니다!")
print("이 예제는 다음을 포함합니다:")
print("- 변수와 데이터 타입")
print("- 배열과 컬렉션")
print("- 제어 구조")
print("- 함수")
print("- 클래스와 상속")
print("- 예외 처리")
print("- 모듈과 네임스페이스")
print("- 제네릭 프로그래밍")
print("- 비동기 프로그래밍")
print("- 메타프로그래밍과 리플렉션")
print("- 매크로")
print("- PSP 특화 보안 기능")
print("- 파일 및 시스템 조작")
print("- 성능 측정")
print("=".repeat(50))
