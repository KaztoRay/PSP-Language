#!/usr/bin/env psp
# -*- coding: utf-8 -*-

/**
 * PSP 실무 프로젝트 예제 모음
 * 실제 보안 업무에서 사용할 수 있는 실용적인 도구들
 */

print("=== PSP 실무 프로젝트 예제 모음 ===\n")

# ============================================================================
# 프로젝트 1: 자동화된 취약점 스캐너 (Automated Vulnerability Scanner)
# ============================================================================

print("프로젝트 1: 자동화된 취약점 스캐너")
print("=".repeat(40))

class VulnerabilityScanner {
    private string target_host
    private int[] target_ports
    private dict<string, string[]> scan_results
    private list<string> vulnerabilities
    
    constructor(string host) {
        this.target_host = host
        this.target_ports = [21, 22, 23, 25, 53, 80, 135, 139, 443, 445, 993, 995, 1433, 3306, 3389, 5432]
        this.scan_results = {}
        this.vulnerabilities = new list<string>()
    }
    
    public void full_scan() {
        printf("대상 호스트 %s에 대한 전체 취약점 스캔 시작\n", this.target_host)
        
        this.host_discovery()
        this.port_scan()
        this.service_detection()
        this.vulnerability_check()
        this.generate_report()
    }
    
    private bool host_discovery() {
        printf("\n[1] 호스트 발견 단계\n")
        
        bool is_alive = ping(this.target_host, 3)
        printf("ICMP 핑: %s\n", is_alive ? "응답" : "무응답")
        
        if (!is_alive) {
            # TCP 핑 시도
            is_alive = tcp_connect(this.target_host, 80, 3)
            printf("TCP 핑 (포트 80): %s\n", is_alive ? "응답" : "무응답")
        }
        
        return is_alive
    }
    
    private void port_scan() {
        printf("\n[2] 포트 스캔 단계\n")
        
        list<int> open_ports = new list<int>()
        
        foreach (port in this.target_ports) {
            bool is_open = tcp_connect(this.target_host, port, 2)
            if (is_open) {
                open_ports.push(port)
                string service = get_service_name(port)
                printf("포트 %d: 열림 (%s)\n", port, service)
            }
        }
        
        this.scan_results["open_ports"] = list_to_string_array(open_ports)
        printf("총 %d개의 열린 포트 발견\n", open_ports.length)
    }
    
    private void service_detection() {
        printf("\n[3] 서비스 탐지 단계\n")
        
        if (this.scan_results.contains_key("open_ports")) {
            string[] open_ports = this.scan_results["open_ports"]
            
            foreach (port_str in open_ports) {
                int port = string_to_int(port_str)
                
                # 배너 그래빙
                string banner = tcp_banner_grab(this.target_host, port, 5)
                if (banner.length > 0) {
                    printf("포트 %d 배너: %s\n", port, banner.trim())
                    this.scan_results[sprintf("banner_%d", port)] = [banner.trim()]
                    
                    # 서비스별 상세 탐지
                    this.detect_service_version(port, banner)
                }
            }
        }
    }
    
    private void detect_service_version(int port, string banner) {
        switch (port) {
            case 22:
                if (banner.contains("OpenSSH")) {
                    string version = extract_ssh_version(banner)
                    printf("SSH 버전: %s\n", version)
                    this.check_ssh_vulnerabilities(version)
                }
                break
                
            case 80:
            case 443:
                dict<string, string> http_info = http_service_info(this.target_host, port)
                if (http_info.contains_key("server")) {
                    printf("웹 서버: %s\n", http_info["server"])
                    this.check_web_vulnerabilities(port, http_info)
                }
                break
                
            case 21:
                if (banner.contains("FTP")) {
                    printf("FTP 서버 감지\n")
                    this.check_ftp_vulnerabilities(banner)
                }
                break
        }
    }
    
    private void check_ssh_vulnerabilities(string version) {
        # SSH 취약점 데이터베이스 (실제로는 CVE 데이터베이스에서 조회)
        dict<string, string[]> ssh_vulns = {
            "OpenSSH 7.4": ["CVE-2018-15473", "CVE-2016-10708"],
            "OpenSSH 6.6": ["CVE-2016-0777", "CVE-2016-0778"],
            "OpenSSH 5.3": ["CVE-2010-4478", "CVE-2010-5107"]
        }
        
        foreach (vuln_version, cves in ssh_vulns) {
            if (version.contains(vuln_version)) {
                foreach (cve in cves) {
                    string vuln_desc = sprintf("SSH 취약점: %s (%s)", cve, vuln_version)
                    this.vulnerabilities.push(vuln_desc)
                    printf("취약점 발견: %s\n", vuln_desc)
                }
            }
        }
    }
    
    private void check_web_vulnerabilities(int port, dict<string, string> info) {
        # 웹 서버별 알려진 취약점
        if (info.contains_key("server")) {
            string server = info["server"]
            
            if (server.contains("Apache/2.2")) {
                this.vulnerabilities.push("Apache 2.2 - 다수의 알려진 취약점")
            } else if (server.contains("nginx/1.10")) {
                this.vulnerabilities.push("Nginx 1.10 - HTTP/2 취약점 (CVE-2018-16843)")
            } else if (server.contains("IIS/7.5")) {
                this.vulnerabilities.push("IIS 7.5 - WebDAV 취약점")
            }
        }
        
        # 일반적인 웹 취약점 테스트
        this.test_common_web_vulns(port)
    }
    
    private void test_common_web_vulns(int port) {
        string base_url = sprintf("http://%s:%d", this.target_host, port)
        
        # 디렉토리 리스팅 확인
        string[] test_dirs = ["admin", "backup", "config", "test"]
        foreach (dir in test_dirs) {
            string url = sprintf("%s/%s", base_url, dir)
            int status = http_get_status(url)
            if (status == 200) {
                this.vulnerabilities.push(sprintf("노출된 디렉토리: /%s", dir))
            }
        }
        
        # 기본 파일 확인
        string[] test_files = ["robots.txt", "sitemap.xml", ".htaccess", "config.php"]
        foreach (file in test_files) {
            string url = sprintf("%s/%s", base_url, file)
            int status = http_get_status(url)
            if (status == 200) {
                this.vulnerabilities.push(sprintf("노출된 파일: /%s", file))
            }
        }
    }
    
    private void check_ftp_vulnerabilities(string banner) {
        # 익명 로그인 테스트
        if (ftp_test_anonymous(this.target_host)) {
            this.vulnerabilities.push("FTP 익명 로그인 허용")
        }
        
        # FTP 배너에서 버전 추출 및 취약점 확인
        if (banner.contains("vsftpd 2.3.4")) {
            this.vulnerabilities.push("vsftpd 2.3.4 백도어 취약점 (CVE-2011-2523)")
        }
    }
    
    private void vulnerability_check() {
        printf("\n[4] 취약점 검증 단계\n")
        printf("총 %d개의 잠재적 취약점 발견\n", this.vulnerabilities.length)
        
        foreach (vuln in this.vulnerabilities) {
            printf("- %s\n", vuln)
        }
    }
    
    private void generate_report() {
        printf("\n[5] 보고서 생성\n")
        
        string report = sprintf("""
# 취약점 스캔 보고서

## 스캔 대상
- 호스트: %s
- 스캔 시간: %s

## 발견된 열린 포트
%s

## 발견된 취약점 (%d개)
%s

## 권장사항
1. 불필요한 서비스 비활성화
2. 소프트웨어 버전 업데이트
3. 강력한 인증 정책 적용
4. 방화벽 규칙 점검
""", 
            this.target_host,
            get_current_time().to_string(),
            array_to_string(this.scan_results.get("open_ports", [])),
            this.vulnerabilities.length,
            list_to_string(this.vulnerabilities)
        )
        
        string report_file = sprintf("./vuln_report_%s.md", this.target_host.replace(".", "_"))
        file_write(report_file, report)
        printf("보고서 저장: %s\n", report_file)
    }
}

# 취약점 스캐너 실행
VulnerabilityScanner scanner = new VulnerabilityScanner("scanme.nmap.org")
scanner.full_scan()

# ============================================================================
# 프로젝트 2: 로그 분석 및 침입 탐지 시스템 (Log Analysis & IDS)
# ============================================================================

print("\n\n프로젝트 2: 로그 분석 및 침입 탐지")
print("=".repeat(40))

class LogAnalyzer {
    private string log_file_path
    private dict<string, int> attack_patterns
    private list<string> alerts
    private dict<string, int> ip_counts
    
    constructor(string log_path) {
        this.log_file_path = log_path
        this.attack_patterns = {
            "sql_injection": 0,
            "xss_attempt": 0,
            "brute_force": 0,
            "directory_traversal": 0,
            "suspicious_user_agent": 0
        }
        this.alerts = new list<string>()
        this.ip_counts = {}
    }
    
    public void analyze_logs() {
        printf("로그 분석 시작: %s\n", this.log_file_path)
        
        this.create_sample_log()
        this.parse_and_analyze()
        this.detect_attacks()
        this.generate_alerts()
    }
    
    private void create_sample_log() {
        # 샘플 웹 서버 로그 생성
        string sample_log = """192.168.1.100 - - [25/Oct/2024:10:15:32 +0000] "GET /index.html HTTP/1.1" 200 1234
192.168.1.101 - - [25/Oct/2024:10:16:45 +0000] "POST /login.php HTTP/1.1" 200 567
10.0.0.50 - - [25/Oct/2024:10:17:23 +0000] "GET /admin/config.php HTTP/1.1" 403 89
192.168.1.102 - - [25/Oct/2024:10:18:01 +0000] "GET /search.php?q=' OR 1=1-- HTTP/1.1" 500 234
192.168.1.103 - - [25/Oct/2024:10:19:15 +0000] "GET /index.php?page=../../../../etc/passwd HTTP/1.1" 404 123
192.168.1.101 - - [25/Oct/2024:10:20:30 +0000] "POST /login.php HTTP/1.1" 401 45
192.168.1.101 - - [25/Oct/2024:10:21:45 +0000] "POST /login.php HTTP/1.1" 401 45
192.168.1.101 - - [25/Oct/2024:10:22:30 +0000] "POST /login.php HTTP/1.1" 401 45
192.168.1.104 - - [25/Oct/2024:10:23:12 +0000] "GET /script.js HTTP/1.1" 200 890
192.168.1.105 - - [25/Oct/2024:10:24:33 +0000] "GET /comment.php?msg=<script>alert('xss')</script> HTTP/1.1" 200 345
"""
        
        file_write(this.log_file_path, sample_log)
        printf("샘플 로그 파일 생성됨\n")
    }
    
    private void parse_and_analyze() {
        printf("로그 파싱 및 분석 중...\n")
        
        if (!file_exists(this.log_file_path)) {
            printf("로그 파일을 찾을 수 없음: %s\n", this.log_file_path)
            return
        }
        
        string log_content = file_read(this.log_file_path)
        string[] log_lines = log_content.split("\n")
        
        foreach (line in log_lines) {
            if (line.length > 0) {
                this.analyze_log_line(line)
            }
        }
    }
    
    private void analyze_log_line(string line) {
        # 정규식으로 로그 라인 파싱
        # 형식: IP - - [timestamp] "method url protocol" status size
        
        string[] parts = line.split(" ")
        if (parts.length < 10) return
        
        string ip = parts[0]
        string method = parts[5].replace("\"", "")
        string url = parts[6]
        string status = parts[8]
        
        # IP 카운트
        if (this.ip_counts.contains_key(ip)) {
            this.ip_counts[ip]++
        } else {
            this.ip_counts[ip] = 1
        }
        
        # 공격 패턴 탐지
        this.detect_attack_patterns(ip, method, url, status, line)
    }
    
    private void detect_attack_patterns(string ip, string method, string url, string status, string full_line) {
        # SQL 인젝션 탐지
        if (url.contains("'") || url.contains("OR 1=1") || url.contains("UNION SELECT") || url.contains("--")) {
            this.attack_patterns["sql_injection"]++
            this.alerts.push(sprintf("[SQL 인젝션] %s에서 %s 요청", ip, url))
        }
        
        # XSS 탐지
        if (url.contains("<script>") || url.contains("alert(") || url.contains("javascript:")) {
            this.attack_patterns["xss_attempt"]++
            this.alerts.push(sprintf("[XSS 시도] %s에서 %s 요청", ip, url))
        }
        
        # 디렉토리 트래버설 탐지
        if (url.contains("../") || url.contains("..\\") || url.contains("/etc/passwd")) {
            this.attack_patterns["directory_traversal"]++
            this.alerts.push(sprintf("[디렉토리 트래버설] %s에서 %s 요청", ip, url))
        }
        
        # 브루트 포스 탐지 (같은 IP에서 로그인 실패 반복)
        if (url.contains("login") && status == "401" && this.ip_counts[ip] > 3) {
            this.attack_patterns["brute_force"]++
            this.alerts.push(sprintf("[브루트 포스] %s에서 반복된 로그인 시도", ip))
        }
        
        # 의심스러운 사용자 에이전트
        if (full_line.contains("sqlmap") || full_line.contains("Nikto") || full_line.contains("Nessus")) {
            this.attack_patterns["suspicious_user_agent"]++
            this.alerts.push(sprintf("[의심스러운 도구] %s에서 스캐닝 도구 사용", ip))
        }
    }
    
    private void detect_attacks() {
        printf("\n공격 패턴 분석 결과:\n")
        
        foreach (pattern, count in this.attack_patterns) {
            if (count > 0) {
                printf("- %s: %d건\n", pattern, count)
            }
        }
        
        # 의심스러운 IP 식별 (요청 수가 비정상적으로 많은 IP)
        printf("\n의심스러운 IP 주소:\n")
        foreach (ip, count in this.ip_counts) {
            if (count > 5) {  # 임계값: 5회 이상
                printf("- %s: %d회 요청\n", ip, count)
                this.alerts.push(sprintf("[의심스러운 활동] %s에서 비정상적으로 많은 요청 (%d건)", ip, count))
            }
        }
    }
    
    private void generate_alerts() {
        printf("\n=== 보안 알림 ===\n")
        
        if (this.alerts.length == 0) {
            printf("탐지된 위협이 없습니다.\n")
            return
        }
        
        printf("총 %d개의 보안 알림 생성됨:\n", this.alerts.length)
        
        foreach (alert in this.alerts) {
            printf("%s [%s]\n", alert, get_current_time().to_string())
        }
        
        # 알림 파일 저장
        string alert_file = "./security_alerts.log"
        string alert_content = ""
        foreach (alert in this.alerts) {
            alert_content += sprintf("%s [%s]\n", alert, get_current_time().to_string())
        }
        
        file_write(alert_file, alert_content)
        printf("\n알림이 %s에 저장되었습니다.\n", alert_file)
    }
}

# 로그 분석기 실행
LogAnalyzer analyzer = new LogAnalyzer("./web_access.log")
analyzer.analyze_logs()

# ============================================================================
# 프로젝트 3: 네트워크 패킷 캡처 및 분석 (Packet Capture & Analysis)
# ============================================================================

print("\n\n프로젝트 3: 네트워크 패킷 분석")
print("=".repeat(40))

class PacketAnalyzer {
    private string interface_name
    private list<dict<string, mixed>> captured_packets
    private dict<string, int> protocol_stats
    private list<string> security_issues
    
    constructor(string interface) {
        this.interface_name = interface
        this.captured_packets = new list<dict<string, mixed>>()
        this.protocol_stats = {}
        this.security_issues = new list<string>()
    }
    
    public void start_capture(int duration_seconds) {
        printf("네트워크 패킷 캡처 시작 (인터페이스: %s, 시간: %d초)\n", 
               this.interface_name, duration_seconds)
        
        this.simulate_packet_capture(duration_seconds)
        this.analyze_packets()
        this.detect_security_issues()
        this.generate_analysis_report()
    }
    
    private void simulate_packet_capture(int duration) {
        printf("패킷 캡처 중...\n")
        
        # 시뮬레이션된 패킷 데이터
        dict<string, mixed>[] sample_packets = [
            {
                "timestamp": get_current_time(),
                "src_ip": "192.168.1.100",
                "dst_ip": "8.8.8.8",
                "src_port": 53124,
                "dst_port": 53,
                "protocol": "UDP",
                "size": 64,
                "payload": "DNS 조회: google.com"
            },
            {
                "timestamp": get_current_time(),
                "src_ip": "192.168.1.101",
                "dst_ip": "192.168.1.1",
                "src_port": 12345,
                "dst_port": 80,
                "protocol": "TCP",
                "size": 1500,
                "payload": "GET /index.html HTTP/1.1"
            },
            {
                "timestamp": get_current_time(),
                "src_ip": "10.0.0.100",
                "dst_ip": "192.168.1.50",
                "src_port": 4444,
                "dst_port": 1234,
                "protocol": "TCP",
                "size": 200,
                "payload": "cmd.exe /c whoami"
            },
            {
                "timestamp": get_current_time(),
                "src_ip": "192.168.1.102",
                "dst_ip": "malicious.domain.com",
                "src_port": 55123,
                "dst_port": 443,
                "protocol": "TCP",
                "size": 850,
                "payload": "HTTPS 연결 시도"
            }
        ]
        
        # 패킷 추가 및 통계 업데이트
        foreach (packet in sample_packets) {
            this.captured_packets.push(packet)
            
            string protocol = packet["protocol"]
            if (this.protocol_stats.contains_key(protocol)) {
                this.protocol_stats[protocol]++
            } else {
                this.protocol_stats[protocol] = 1
            }
            
            sleep(100)  # 패킷 캡처 시뮬레이션
        }
        
        printf("총 %d개 패킷 캡처 완료\n", this.captured_packets.length)
    }
    
    private void analyze_packets() {
        printf("\n패킷 분석 중...\n")
        
        # 프로토콜 통계
        printf("프로토콜 분포:\n")
        foreach (protocol, count in this.protocol_stats) {
            printf("- %s: %d 패킷\n", protocol, count)
        }
        
        # 상위 통신 호스트
        dict<string, int> host_stats = {}
        foreach (packet in this.captured_packets) {
            string src_ip = packet["src_ip"]
            string dst_ip = packet["dst_ip"]
            
            if (host_stats.contains_key(src_ip)) {
                host_stats[src_ip]++
            } else {
                host_stats[src_ip] = 1
            }
            
            if (host_stats.contains_key(dst_ip)) {
                host_stats[dst_ip]++
            } else {
                host_stats[dst_ip] = 1
            }
        }
        
        printf("\n상위 통신 호스트:\n")
        foreach (ip, count in host_stats) {
            if (count > 1) {
                printf("- %s: %d회\n", ip, count)
            }
        }
    }
    
    private void detect_security_issues() {
        printf("\n보안 이슈 탐지 중...\n")
        
        foreach (packet in this.captured_packets) {
            string src_ip = packet["src_ip"]
            string dst_ip = packet["dst_ip"]
            int src_port = packet["src_port"]
            int dst_port = packet["dst_port"]
            string payload = packet["payload"]
            
            # 의심스러운 포트 사용
            if (dst_port == 4444 || dst_port == 1234 || dst_port == 31337) {
                this.security_issues.push(sprintf("의심스러운 포트 사용: %s:%d -> %s:%d", 
                                                  src_ip, src_port, dst_ip, dst_port))
            }
            
            # 악성 명령어 탐지
            if (payload.contains("cmd.exe") || payload.contains("powershell") || payload.contains("/bin/bash")) {
                this.security_issues.push(sprintf("악성 명령어 탐지: %s에서 %s로 '%s'", 
                                                  src_ip, dst_ip, payload))
            }
            
            # 알려진 악성 도메인
            if (dst_ip.contains("malicious") || dst_ip.contains("evil") || dst_ip.contains("botnet")) {
                this.security_issues.push(sprintf("악성 도메인 통신: %s -> %s", src_ip, dst_ip))
            }
            
            # 비정상적인 패킷 크기
            int size = packet["size"]
            if (size > 9000) {  # Jumbo 프레임
                this.security_issues.push(sprintf("비정상적인 패킷 크기: %d 바이트 (%s -> %s)", 
                                                  size, src_ip, dst_ip))
            }
            
            # 평문 자격 증명 탐지
            if (payload.contains("password=") || payload.contains("login:") || payload.contains("Authorization: Basic")) {
                this.security_issues.push(sprintf("평문 자격 증명 탐지: %s -> %s", src_ip, dst_ip))
            }
        }
        
        printf("발견된 보안 이슈: %d건\n", this.security_issues.length)
    }
    
    private void generate_analysis_report() {
        printf("\n=== 패킷 분석 보고서 ===\n")
        
        string report = sprintf("""
# 네트워크 패킷 분석 보고서

## 캡처 정보
- 인터페이스: %s
- 분석 시간: %s
- 총 패킷 수: %d

## 프로토콜 분포
%s

## 발견된 보안 이슈 (%d건)
%s

## 권장 조치사항
1. 의심스러운 포트 통신 차단
2. 악성 도메인 DNS 필터링
3. 네트워크 모니터링 강화
4. 평문 통신 암호화 적용
""",
            this.interface_name,
            get_current_time().to_string(),
            this.captured_packets.length,
            this.format_protocol_stats(),
            this.security_issues.length,
            list_to_string(this.security_issues)
        )
        
        string report_file = "./packet_analysis_report.md"
        file_write(report_file, report)
        printf("분석 보고서 저장: %s\n", report_file)
    }
    
    private string format_protocol_stats() {
        string result = ""
        foreach (protocol, count in this.protocol_stats) {
            result += sprintf("- %s: %d 패킷\n", protocol, count)
        }
        return result
    }
}

# 패킷 분석기 실행
PacketAnalyzer packet_analyzer = new PacketAnalyzer("eth0")
packet_analyzer.start_capture(10)  # 10초간 캡처

# ============================================================================
# 정리 및 마무리
# ============================================================================

print("\n\n=== 실무 프로젝트 예제 완료 ===")
print("생성된 파일들:")

string[] generated_files = [
    "./vuln_report_scanme_nmap_org.md",
    "./web_access.log", 
    "./security_alerts.log",
    "./packet_analysis_report.md"
]

foreach (file in generated_files) {
    if (file_exists(file)) {
        printf("✓ %s\n", file)
    }
}

print("\n이 예제들은 실제 보안 업무에서 활용할 수 있는:")
print("1. 자동화된 취약점 스캐너")
print("2. 로그 분석 및 침입 탐지 시스템") 
print("3. 네트워크 패킷 캡처 및 분석 도구")
print("를 구현했습니다.")

print("\n각 도구는 확장 가능하며, 실제 환경에 맞게 커스터마이징할 수 있습니다.")
